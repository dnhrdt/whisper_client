[33mcommit 4e1c686c7579e79660af523795c701409cf2c443[m
Author: dnhrdt <github@deinhardt.com>
Date:   Thu Feb 13 21:52:37 2025 +0100

    chore: Save current state as test baseline - Set generous timeouts - Prepare for systematic testing

[1mdiff --git a/src/audio.py b/src/audio.py[m
[1mindex d0b2a4d..ac90c86 100644[m
[1m--- a/src/audio.py[m
[1m+++ b/src/audio.py[m
[36m@@ -5,9 +5,7 @@[m [mimport pyaudio[m
 import numpy as np[m
 import threading[m
 import config[m
[31m-from src import logging[m
[31m-[m
[31m-logger = logging.get_logger()[m
[32m+[m[32mfrom src import logger[m
 [m
 class AudioManager:[m
     def __init__(self):[m
[36m@@ -123,14 +121,7 @@[m [mclass AudioManager:[m
             logger.debug("Stoppe Aufnahme...")[m
             self.recording = False[m
             [m
[31m-            # Warte auf Audio-Thread[m
[31m-            if hasattr(self, 'record_thread') and self.record_thread.is_alive():[m
[31m-                logger.debug("Warte auf Audio-Thread...")[m
[31m-                self.record_thread.join(timeout=1.0)[m
[31m-                if self.record_thread.is_alive():[m
[31m-                    logger.warning("Audio-Thread reagiert nicht!")[m
[31m-            [m
[31m-            # Stream schlie√üen[m
[32m+[m[32m            # Stream sofort schlie√üen um weitere Daten zu verhindern[m
             if self.stream:[m
                 try:[m
                     self.stream.stop_stream()[m
[36m@@ -140,6 +131,15 @@[m [mclass AudioManager:[m
                 except Exception as e:[m
                     logger.error(f"Fehler beim Schlie√üen des Streams: {e}")[m
             [m
[32m+[m[32m            # Warte auf Audio-Thread mit l√§ngerem Timeout[m
[32m+[m[32m            if hasattr(self, 'record_thread') and self.record_thread.is_alive():[m
[32m+[m[32m                logger.debug("Warte auf Audio-Thread...")[m
[32m+[m[32m                self.record_thread.join(timeout=2.0)[m
[32m+[m[32m                if self.record_thread.is_alive():[m
[32m+[m[32m                    logger.warning("Audio-Thread reagiert nicht - Beende Thread...")[m
[32m+[m[32m                    # Thread als Daemon markiert, wird beim Programm-Ende beendet[m
[32m+[m[32m                    self.record_thread = None[m
[32m+[m[41m            [m
             logger.info("\n‚èπÔ∏è Aufnahme gestoppt")[m
     [m
     def _record_audio(self, callback):[m
[36m@@ -148,13 +148,8 @@[m [mclass AudioManager:[m
         logger.debug("Audio-Thread gestartet")[m
         [m
         try:[m
[31m-            while self.recording:[m
[32m+[m[32m            while self.recording and self.stream and self.stream.is_active():[m
                 try:[m
[31m-                    # Pr√ºfe ob Stream noch aktiv[m
[31m-                    if not self.stream or not self.stream.is_active():[m
[31m-                        logger.error("Audio-Stream nicht aktiv!")[m
[31m-                        break[m
[31m-                    [m
                     data = self.stream.read(self.chunk, exception_on_overflow=False)[m
                     # Konvertiere zu float32 Array[m
                     audio_array = np.frombuffer(data, dtype=np.int16).astype(np.float32) / 32768.0[m
[36m@@ -165,7 +160,8 @@[m [mclass AudioManager:[m
                     # Sende gepufferte Daten wenn genug vorhanden[m
                     if len(buffer) >= 4:  # ca. 1 Sekunde Audio[m
                         combined_array = np.concatenate(buffer)[m
[31m-                        callback(combined_array.tobytes())[m
[32m+[m[32m                        if self.recording:  # Nochmal pr√ºfen vor dem Senden[m
[32m+[m[32m                            callback(combined_array.tobytes())[m
                         buffer = []  # Puffer leeren[m
                         [m
                 except Exception as e:[m
[36m@@ -173,8 +169,17 @@[m [mclass AudioManager:[m
                     break[m
                     [m
         finally:[m
[32m+[m[32m            # Sende verbleibende Puffer-Daten[m
[32m+[m[32m            if buffer:[m
[32m+[m[32m                try:[m
[32m+[m[32m                    combined_array = np.concatenate(buffer)[m
[32m+[m[32m                    callback(combined_array.tobytes())[m
[32m+[m[32m                    logger.debug(f"Letzte {len(buffer)} Puffer-Chunks gesendet")[m
[32m+[m[32m                except Exception as e:[m
[32m+[m[32m                    logger.error(f"Fehler beim Senden der letzten Puffer-Daten: {e}")[m
[32m+[m[41m            [m
[32m+[m[32m            buffer = [][m
             logger.debug("Audio-Thread beendet")[m
[31m-            # Stelle sicher, dass Aufnahme gestoppt wird[m
             self.recording = False[m
     [m
     def cleanup(self):[m

[33mcommit 2d27ac03ae5e1d7f223a59e3a4e0c2d2bb636c72[m[33m ([m[1;31morigin/feature/text-insertion[m[33m)[m
Author: dnhrdt <github@deinhardt.com>
Date:   Wed Feb 12 22:55:05 2025 +0100

    feat: Refactor project structure and add core modules
    - Split code into separate modules
    - Add config handling
    - Improve text insertion
    - Add logging system

[1mdiff --git a/src/audio.py b/src/audio.py[m
[1mnew file mode 100644[m
[1mindex 0000000..d0b2a4d[m
[1m--- /dev/null[m
[1m+++ b/src/audio.py[m
[36m@@ -0,0 +1,184 @@[m
[32m+[m[32m"""[m
[32m+[m[32mAudio-Verarbeitungsmodul f√ºr den Whisper-Client[m
[32m+[m[32m"""[m
[32m+[m[32mimport pyaudio[m
[32m+[m[32mimport numpy as np[m
[32m+[m[32mimport threading[m
[32m+[m[32mimport config[m
[32m+[m[32mfrom src import logging[m
[32m+[m
[32m+[m[32mlogger = logging.get_logger()[m
[32m+[m
[32m+[m[32mclass AudioManager:[m
[32m+[m[32m    def __init__(self):[m
[32m+[m[32m        self.audio = pyaudio.PyAudio()[m
[32m+[m[32m        self.stream = None[m
[32m+[m[32m        self.recording = False[m
[32m+[m[32m        self.recording_lock = threading.Lock()[m
[32m+[m[41m        [m
[32m+[m[32m        # Audio-Format aus Config laden[m
[32m+[m[32m        self.chunk = config.AUDIO_CHUNK[m
[32m+[m[32m        self.format = getattr(pyaudio, config.AUDIO_FORMAT)[m
[32m+[m[32m        self.channels = config.AUDIO_CHANNELS[m
[32m+[m[32m        self.rate = config.AUDIO_RATE[m
[32m+[m[32m        self.device_index = config.AUDIO_DEVICE_INDEX[m
[32m+[m[41m        [m
[32m+[m[32m        # Mikrofon initialisieren[m
[32m+[m[32m        self._init_microphone()[m
[32m+[m[41m    [m
[32m+[m[32m    def _init_microphone(self):[m
[32m+[m[32m        """Mikrofonzugriff initialisieren und testen"""[m
[32m+[m[32m        if not self._check_microphone():[m
[32m+[m[32m            logger.error("‚ö†Ô∏è Mikrofon nicht verf√ºgbar!")[m
[32m+[m[32m            raise RuntimeError("Kein Mikrofon gefunden")[m
[32m+[m[41m            [m
[32m+[m[32m        # Teste Mikrofonzugriff[m
[32m+[m[32m        try:[m
[32m+[m[32m            test_stream = self.audio.open([m
[32m+[m[32m                format=self.format,[m
[32m+[m[32m                channels=self.channels,[m
[32m+[m[32m                rate=self.rate,[m
[32m+[m[32m                input=True,[m
[32m+[m[32m                input_device_index=self.device_index,[m
[32m+[m[32m                frames_per_buffer=self.chunk[m
[32m+[m[32m            )[m
[32m+[m[32m            test_stream.close()[m
[32m+[m[32m            logger.info("‚úì Mikrofontest erfolgreich")[m
[32m+[m[32m        except Exception as e:[m
[32m+[m[32m            logger.error(f"‚ö†Ô∏è Mikrofontest fehlgeschlagen: {e}")[m
[32m+[m[32m            raise[m
[32m+[m[41m    [m
[32m+[m[32m    def _check_microphone(self):[m
[32m+[m[32m        """Pr√ºft ob das konfigurierte Mikrofon verf√ºgbar ist"""[m
[32m+[m[32m        try:[m
[32m+[m[32m            info = self.audio.get_host_api_info_by_index(0)[m
[32m+[m[32m            num_devices = info.get('deviceCount')[m
[32m+[m[41m            [m
[32m+[m[32m            if self.device_index < num_device